컴파일 --> TestJava.class

C:> javac TestJava

실행

C:> java TestJava

jvm 이 프로그램을 실행할 때는 TestJava.class를 가지고 실행한다.

---------------------------------------

1). 아래와 같은 명령행으로 프로그램을 실행하였을 때 결과는 무엇인가? 

C:> javac TestJava 123

public class TestJava
public static void main(String args[])
System.out.println(args[1]);
  
  답: 인덱스 예외가 발생한다.
  설명: 매개변수에 배열이 있는데 그냥 실행하면 배열에 null을 대입하고 실행시킨다.
123을 args 배열의 0번째 인덱스에 넣어주는 코드인데 1번째 인덱스를 출력하라고 하면 1번째 방은 비어있는 방으로
인덱스 예외가 발생한다. (ArrayIndexOutOfException)

-----------------------
  우리가 코드 작업하는 것은 자바 파일이고 실제로 실행하는 것은 클래스 파일이다.
  수정이 이루어졌을 땐 무조건 컴파일 후 실행해야한다.
  C언어는 자바처럼 인터프리터 방식이 아니라 컴파일하고 전체가 실행된다. 
  그래서 어디서 에러가 났는지 모르기 때문에 디버깅을 해야한다. (역순으로 되짚어가면서 에러를 찾는 방식)
  자바 같은 인터프리터 언어는 라인별로 실행을 하니까 디버깅 할 필요가 없다.
---------------------

2). 다음 프로그램의 컴파일 결과를 예상하라.

class Test
	static int a = 1;
	public static void main(String[] args)
		int a;
		System.out.println(a);

	답:  a 값이 초기화가 되어있지 않아서 에러가 발생한다.
	설명: 블럭이 같다면 statix으로 선언한 변수와 지역변수는 이름이 같아도 된다. 
하지만 같은 영역 안에 변수가 선언됐을 땐 이름이 구별되어야 한다. 
변수 이름이 같은 경우엔 지역변수를 먼저 쓴다. 그런데 지역변수는 사용되기 전에 반드시 값이 대입되어야 한다.
즉, 선언 후 초기화가 이루어져야 한다는 뜻이다.

--------------------------

2번 문제 응용

class Test
	int a = 1;		// 지역변수 - 인스턴스
	static int b = 1;	// 클래스 변수

	public static void main(String[] args) {
		System.out.println(a);
		System.out.println(b);
	}	// 클래스 메서드
	public  void aaa(String[] args) {
		System.out.println(a);
		System.out.println(b);
	}	// 지역변수 메서드 - 인스턴스
}

 컴퓨터에서 프로그램이 실행될 때, 메모리라는 공간에 코드와 데이터가 저장돼. 여기서 중요한 개념은 "언제"와 "어떻게" 메모리에 저장되는지야. 이걸 예를 들어 설명할게.

### 클래스와 인스턴스
- **클래스**: 설계도 같은 거야. 여기서는 `Test`라는 설계도를 만든 거지.
- **인스턴스**: 설계도를 바탕으로 실제로 만들어진 물건이야. `Test` 클래스로 여러 개의 인스턴스를 만들 수 있어.

### 변수와 메서드
- **인스턴스 변수 (a)**: 각 인스턴스마다 따로 저장되는 변수야. 여기서 `int a`가 인스턴스 변수야.
- **클래스 변수 (b)**: 모든 인스턴스가 공유하는 변수야. 여기서 `static int b`가 클래스 변수야.
- **메서드**: 클래스나 인스턴스가 할 수 있는 행동이나 기능이야. 여기서는 `main`과 `aaa`가 메서드야.

### 메모리에 올라가는 순서

1. **클래스 로딩**:
    - 프로그램이 실행되면 제일 먼저 `Test`라는 클래스가 메모리에 올라가.
    - 이 때, 클래스 변수 `b`도 메모리에 올라가. 왜냐하면 `b`는 static 변수니까 클래스가 로딩될 때 함께 올라가거든.
    
    ```java
    static int b = 1; // 이때 b는 메모리에 저장돼.
    ```

2. **main 메서드 실행**:
    - `main` 메서드는 프로그램의 시작점이야. `main` 메서드가 실행될 때는 아직 `Test` 클래스의 인스턴스가 없어. 
    - 그래서 `a`는 아직 메모리에 올라가지 않았어. `main` 메서드는 클래스 메서드니까 `b`에 접근할 수 있어.
    - 하지만 `a`에 접근하려고 하면 오류가 나. 왜냐하면 `a`는 인스턴스 변수인데 인스턴스가 아직 없으니까.
    
    ```java
    public static void main(String[] args) {
        // System.out.println(a); // 오류가 나
        System.out.println(b); // 출력 가능
    }
    ```

3. **인스턴스 생성**:
    - 만약 인스턴스를 만들면, 그때 `a`가 메모리에 올라가.
    - 예를 들어, `Test t = new Test();` 이렇게 하면 `a`라는 변수가 메모리에 저장돼.
    
    ```java
    Test t = new Test(); // 이때 a가 메모리에 저장돼
    ```

4. **aaa 메서드 실행**:
    - 인스턴스를 만들고 나서 `aaa` 메서드를 호출하면, 이 메서드는 인스턴스 메서드라서 `a`와 `b` 모두 접근할 수 있어.
    
    ```java
    t.aaa(); // 이때 a와 b 모두 출력 가능
    ```

### 메모리에 올라가는 순서 요약
1. `Test` 클래스가 로딩되면서 `b`가 메모리에 저장돼.
2. `main` 메서드가 실행되지만, `a`는 아직 메모리에 없어서 사용할 수 없어.
3. 인스턴스를 생성하면 `a`가 메모리에 저장돼.
4. 인스턴스 메서드 `aaa`를 호출하면 `a`와 `b` 모두 접근할 수 있어.











